[
  {
    "lessonTitle": "Funksiyalar və Scope",
    "theory_questions": [
      { "question": "JavaScript-də funksiya nədir?", "answer": "Funksiya, müəyyən bir tapşırığı yerinə yetirmək üçün nəzərdə tutulmuş təkrar istifadə edilə bilən kod blokudur." },
      { "question": "`function declaration` və `function expression` arasındakı fərq nədir?", "answer": "`Function declaration` hosting-ə məruz qalır, `function expression` isə yalnız təyin olunduqdan sonra çağırıla bilər." },
      { "question": "Arrow Function nədir?", "answer": "Arrow function qısa sintaksisə malik funksiyadır və öz `this` kontekstinə sahib deyil." },
      { "question": "`scope` nədir?", "answer": "Scope dəyişənlərin və funksiyaların əlçatan olduğu kontekstdir." },
      { "question": "`closure` nədir?", "answer": "Closure, bir funksiyanın öz əhatə dairəsindəki dəyişənlərə giriş imkanı saxlamasıdır." },
      { "question": "`this` necə işləyir?", "answer": "`this` funksiyanın necə çağırıldığına görə dəyişir. Arrow function-da `this` yuxarıdakı scope-dan gəlir." },
      { "question": "IIFE nədir?", "answer": "Dərhal çağırılan funksiya ifadəsidir, təcrid olunmuş scope yaratmaq üçün istifadə olunur." },
      { "question": "Callback funksiyası nədir?", "answer": "Callback başqa funksiyaya arqument kimi ötürülən və sonra çağırılan funksiyadır." },
      { "question": "`Pure Function` nədir?", "answer": "Eyni giriş üçün həmişə eyni nəticə qaytaran və yan təsiri olmayan funksiyadır." },
      { "question": "`var`, `let`, `const` fərqi nədir?", "answer": "`var` function scope-ludur, `let` və `const` block scope-ludur." },
      { "question": "Hoisting nədir?", "answer": "Dəyişən və funksiyaların yuxarıya qaldırılması hadisəsidir." },
      { "question": "Block Scope nədir?", "answer": "Məsələn `{}` içərisində təyin olunan dəyişənlərin yalnız həmin blokda əlçatan olmasıdır." },
      { "question": "Function Scope nədir?", "answer": "Funksiya içində təyin olunan dəyişənlərin yalnız həmin funksiyada görünməsidir." },
      { "question": "Lexical Scope nədir?", "answer": "Funksiya harada yaradılıbsa, həmin yerdəki scope-a giriş edə bilməsidir." },
      { "question": "High Order Function nədir?", "answer": "Başqa funksiyanı arqument kimi qəbul edən və ya funksiyanı qaytaran funksiyadır." },
      { "question": "Currying nədir?", "answer": "Bir funksiyanın birdən çox arqumentini tək-tək qəbul edən ardıcıl funksiyalara bölməkdir." },
      { "question": "Function Composition nədir?", "answer": "Birdən çox funksiyanın nəticəsini bir-birinə ötürərək yeni funksiya yaratmaqdır." },
      { "question": "Immediately Invoked Function Expression nə işə yarayır?", "answer": "Global scope-u çirkləndirmədən lokal icra mühiti yaradır." },
      { "question": "Recursion nədir?", "answer": "Funksiyanın öz-özünü çağırmasıdır." },
      { "question": "Tail Recursion nədir?", "answer": "Funksiya özünü ən sonda çağırırsa, bu performans baxımından optimallaşdırıla bilir." },
      { "question": "Anonymous Function nədir?", "answer": "Adı olmayan funksiyadır, adətən callback olaraq istifadə olunur." },
      { "question": "Default parameter nədir?", "answer": "Parametr ötürülmədikdə avtomatik təyin olunan dəyərdir." },
      { "question": "Rest parameter nədir?", "answer": "Bir neçə arqumenti array kimi qəbul etməyə imkan verir (`...args`)." },
      { "question": "Spread operator nə edir?", "answer": "Array və obyektləri genişləndirərək fərdi elementlərə ayırır." },
      { "question": "Arrow function-da `this` necə davranır?", "answer": "Arrow function-da `this` lexical scope-dan gəlir." },
      { "question": "Function binding nədir?", "answer": "`bind` funksiyası `this` kontekstini daimi bir obyektə bağlayır." },
      { "question": "Call və Apply fərqi nədir?", "answer": "`call` arqumentləri vergüllə, `apply` isə massivlə qəbul edir." },
      { "question": "Function Hoisting necə işləyir?", "answer": "Function declaration yuxarıya qaldırılır və əvvəl çağırıla bilər." },
      { "question": "Function Expression niyə hoist edilmir?", "answer": "Çünki o, dəyişənə təyin edilir və dəyişən `undefined` olur." },
      { "question": "Closuredə dəyişənlər necə saxlanılır?", "answer": "Lexical scope-da bağlanır və funksiya bağlanandan sonra belə saxlanılır." },
      { "question": "Callback Hell nədir?", "answer": "Bir-birinin içində çoxlu callback-lərin yazılması nəticəsində kodun oxunmaz olması." },
      { "question": "Promise nə üçündür?", "answer": "Asinxron əməliyyatların idarə olunması üçün istifadə olunur." },
      { "question": "Async/Await necə işləyir?", "answer": "Promise-ləri oxunaqlı formada idarə etməyə imkan verir." },
      { "question": "Event Loop nədir?", "answer": "JavaScript-in asinxron əməliyyatları idarə edən mexanizmidir." },
      { "question": "SetTimeout və SetInterval fərqi nədir?", "answer": "`setTimeout` bir dəfə, `setInterval` təkrarlanan əməliyyat üçün istifadə olunur." },
      { "question": "Debounce nədir?", "answer": "Bir funksiyanın çox tez-tez çağırılmasının qarşısını alır, son çağırışdan sonra işə düşür." },
      { "question": "Throttle nədir?", "answer": "Bir funksiyanın müəyyən intervalla çağırılmasına icazə verir." },
      { "question": "Callback funksiyalar harda istifadə olunur?", "answer": "Event handling, setTimeout, API çağırışları və async əməliyyatlarda." },
      { "question": "Pure və Impure function fərqi nədir?", "answer": "Pure dəyişənlərə təsir etmir, impure təsir edir." },
      { "question": "Function arguments obyektidirmi?", "answer": "Bəli, array-ə bənzər obyekt kimi mövcuddur." },
      { "question": "`new Function()` necə işləyir?", "answer": "Stringdən dinamik funksiya yaradır." },
      { "question": "Arrow function `arguments` obyektinə malikdirmi?", "answer": "Xeyr, arrow function-da `arguments` yoxdur." },
      { "question": "Function default values ES6-da necə yazılır?", "answer": "Parametrə dəyər bərabərliklə verilir, məsələn `(a=5)=>{}`" },
      { "question": "Nested function nədir?", "answer": "Bir funksiyanın içərisində başqa funksiya yaratmaqdır." },
      { "question": "JavaScript funksiyaları obyekt sayılırmı?", "answer": "Bəli, onlar obyekt tipindədir və property-ləri ola bilər." },
      { "question": "Arrow function-da `prototype` varmı?", "answer": "Xeyr, arrow funksiyaların `prototype` property-si yoxdur." },
      { "question": "Immediately executed arrow function necə yazılır?", "answer": "(() => { console.log('run'); })();" },
      { "question": "Function chaining nədir?", "answer": "Funksiya ardıcıllığı ilə obyekt metodlarını bir-birinə bağlama texnikasıdır." },
      { "question": "Callback funksiyalarının problemi nədir?", "answer": "Nested strukturlar yaradır və kodun saxlanmasını çətinləşdirir." },
      { "question": "Async await error handling necə aparılır?", "answer": "`try...catch` bloku ilə səhv idarə olunur." },
      { "question": "Generator funksiyalar nədir?", "answer": "Generator funksiyalar `function*` ilə yaradılır və `yield` açar sözü ilə nəticələri addım-addım qaytarır." },
      { "question": "Iterator nədir və necə işləyir?", "answer": "Iterator obyektlərdə ardıcıl olaraq elementlərə giriş etməyə imkan verən interfeysdir (`next()` metodu ilə işləyir)." },
      { "question": "Callback Hell problemini necə həll edirik?", "answer": "Promise və async/await istifadə edərək callback hell problemini aradan qaldırmaq olar." },
      { "question": "Promise.all və Promise.race fərqi nədir?", "answer": "`Promise.all` bütün promise-lərin nəticəsini qaytarır, `Promise.race` isə birincisi tamamlanan promise-in nəticəsini." },
      { "question": "Event bubbling və capturing nədir?", "answer": "Event bubbling hadisələrin DOM ağacında yuxarı doğru, capturing isə aşağı doğru ötürülməsidir." },
      { "question": "Context nədir və necə dəyişir?", "answer": "Context funksiyanın çağırıldığı obyektə əsasən `this`-in dəyəridir. `bind`, `call`, `apply` ilə dəyişmək mümkündür." },
      { "question": "Immediately Invoked Arrow Function necə yazılır?", "answer": "(() => { console.log('Run'); })();" },
      { "question": "Factory Function nədir?", "answer": "Factory function obyekt yaradan və qaytaran funksiyadır, `new` açar sözü olmadan işləyir." },
      { "question": "Constructor Function nədir?", "answer": "`new` ilə çağırılan və obyektin instansını yaradan funksiyadır." },
      { "question": "Prototype nədir və nəyə lazımdır?", "answer": "Prototype obyektlərə miras (inheritance) xüsusiyyəti verir, hər obyekt `__proto__` ilə əlaqəlidir." },
      { "question": "Arrow function ilə constructor niyə mümkün deyil?", "answer": "Çünki arrow function-ların `prototype`-u yoxdur və `this`-i sabitdir." },
      { "question": "Immediately Invoked Function nə üçün istifadə olunur?", "answer": "Global namespace-in çirklənməsinin qarşısını almaq üçün." },
      { "question": "Module Pattern nədir?", "answer": "Kodun parçalanmasını və dəyişənlərin gizlədilməsini təmin edən dizayn pattern-dir." },
      { "question": "Singleton pattern nədir?", "answer": "Bir obyektin yalnız bir instansının yaradılmasını təmin edən pattern-dir." },
      { "question": "Memoization nədir?", "answer": "Eyni arqumentlərlə çağırıldıqda nəticəni yadda saxlayaraq performansı artıran texnikadır." },
      { "question": "Currying nə işə yarayır?", "answer": "Funksiyanı tək parametrli funksiyalara bölərək kodu daha çevik edir." },
      { "question": "Pure function-ların üstünlüyü nədir?", "answer": "Test edilə bilən, təkrarlana bilən və yan təsirsiz kod yazmağa imkan verir." },
      { "question": "Asinxron və sinxron funksiyalar fərqi nədir?", "answer": "Sinxron funksiyalar ardıcıl icra olunur, asinxronlar isə `event loop` vasitəsilə sonraya buraxılır." },
      { "question": "Promise chaining necə işləyir?", "answer": "Bir promise-in nəticəsi digər `then()`-ə ötürülür." },
      { "question": "Async function hər zaman nə qaytarır?", "answer": "Async funksiyalar həmişə Promise qaytarır." },
      { "question": "JSON.stringify və JSON.parse nə üçündür?", "answer": "Obyekti stringə çevirmək və ya stringi obyektə çevirmək üçün istifadə olunur." },
      { "question": "Deep copy və shallow copy fərqi nədir?", "answer": "Shallow copy bir səviyyəlik kopyadır, deep copy isə bütün səviyyələri kopyalayır." },
      { "question": "Spread operator və Object.assign fərqi nədir?", "answer": "Spread ES6 sintaksisidir, Object.assign daha köhnə üsuldur; hər ikisi obyekt birləşdirmək üçündür." },
      { "question": "Destructuring nədir?", "answer": "Array və obyektlərdən məlumat çıxarmaq üçün qısa sintaksisdir." },
      { "question": "Immediately Invoked Generator necə çağırılır?", "answer": "(function* () { yield 1; })().next();" },
      { "question": "Hoisting-in riskləri nədir?", "answer": "Dəyişənlərin `undefined` olması və gözlənilməz davranışlara səbəb ola bilməsidir." },
      { "question": "Callback error-first pattern nədir?", "answer": "Node.js-də ənənəvi callback-lərin ilk arqumenti error olur (`callback(err, data)`)." },
      { "question": "Promise.resolve və Promise.reject nə edir?", "answer": "Promise-ləri əl ilə uğurlu və ya uğursuz vəziyyətə gətirir." },
      { "question": "Promise.finally nə edir?", "answer": "Uğur və ya səhv halından asılı olmayaraq hər zaman işləyir." },
      { "question": "Event delegation nədir?", "answer": "Hadisəni valideynə qoşaraq bütün övlad elementləri üçün idarə etmək üsuludur." },
      { "question": "Async Iterator nədir?", "answer": "Asinxron məlumat ardıcıllığını `for await...of` ilə iterasiya etməyə imkan verir." },
      { "question": "Temporal Dead Zone nədir?", "answer": "`let` və `const` dəyişənləri təyin olunmadan istifadə edilən mərhələdir." },
      { "question": "Function parameter destructuring necə edilir?", "answer": "Parametr olaraq obyekt və ya array parçalanaraq qəbul edilir, məsələn `function fn({a,b}){}`" },
      { "question": "Dynamic import nədir?", "answer": "Modulu asinxron şəkildə yükləməyə imkan verir (`import('module.js')`)." },
      { "question": "Module export və default export fərqi nədir?", "answer": "Bir modulda bir default export, amma çox sayda named export ola bilər." },
      { "question": "Revealing module pattern nədir?", "answer": "Funksiyalar və dəyişənləri yalnız qaytarılan obyekt vasitəsilə əlçatan etmək üsuludur." },
      { "question": "Event loop-un stack və queue fərqi nədir?", "answer": "Stack sinxron kodu, queue isə callback və promise-ləri saxlayır." },
      { "question": "Microtask və macrotask fərqi nədir?", "answer": "Microtask (promise) queue prioritetlidir, macrotask (timeout) isə sonra işlənir." },
      { "question": "Scope chain nədir?", "answer": "Daxili funksiyanın xarici scope-lara ardıcıl baxış mexanizmidir." },
      { "question": "Block scope ilə function scope fərqi nədir?", "answer": "`let` və `const` block-a, `var` isə funksiyaya bağlıdır." },
      { "question": "Arrow function 'arguments' obyektini niyə dəstəkləmir?", "answer": "Çünki arrow function-ın öz `arguments` konteksti yoxdur." },
      { "question": "Bind metodunun istifadəsi nə vaxt lazımdır?", "answer": "`this` konteksti itiriləndə (məsələn event listener-də) istifadə olunur." },
      { "question": "Function memoization harada istifadə olunur?", "answer": "Məsələn, API nəticələrinin və ya hesablamaların cache edilməsi üçün." },
      { "question": "Function decorator nədir?", "answer": "Mövcud funksiyanın davranışını dəyişmədən üzərinə əlavə xüsusiyyətlər əlavə edən funksiya." },
      { "question": "Partial application nədir?", "answer": "Funksiya arqumentlərinin bir hissəsini əvvəlcədən doldurmaq üsuludur." },
      { "question": "Callback-lər Promise-lərlə necə əvəz olunur?", "answer": "Callback funksiyalar əvəzinə Promise return edən funksiyalar yazılır." },
      { "question": "Lazy evaluation nədir?", "answer": "Dəyərin yalnız lazım olduqda hesablanması üsuludur." },
      { "question": "Immediately invoked async function necə yazılır?", "answer": "(async()=>{await someTask();})();" }
    ],
    "practice_tasks": [
      { "title": "İki ədədi toplayan funksiya", "description": "İki ədədi qəbul edib cəmini qaytaran funksiya yazın.", "solution": "function sum(a,b){return a+b;}" },
      { "title": "Ən böyük ədədi tap", "description": "Massivdəki ən böyük ədədi tapın.", "solution": "function maxNum(arr){return Math.max(...arr);}" },
      { "title": "Closure Counter", "description": "Hər çağırışda 1 artıran closure yazın.", "solution": "function counter(){let c=0;return()=>++c;}" },
      { "title": "Delay Funksiya", "description": "`setTimeout` ilə 2 saniyə sonra mesaj verin.", "solution": "function delay(cb,ms){setTimeout(cb,ms);}" },
      { "title": "Fullname qaytaran funksiya", "description": "Ad və soyadı birləşdirib qaytarsın.", "solution": "const fullName=(a,b)=>`${a} ${b}`;" },
      { "title": "Array Filter", "description": "Cüt ədədləri qaytaran funksiya yazın.", "solution": "const even=(arr)=>arr.filter(n=>n%2===0);" },
      { "title": "Sum Reduce ilə", "description": "Massiv cəmini reduce ilə tapın.", "solution": "const total=arr=>arr.reduce((a,b)=>a+b,0);" },
      { "title": "Debounce", "description": "Funksiyanın təkrarlanan çağırışlarını gecikdirin.", "solution": "function debounce(fn,delay){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),delay)}}" },
      { "title": "Throttle", "description": "Funksiyanı müəyyən intervalda çağırın.", "solution": "function throttle(fn,delay){let t=false;return(...a)=>{if(!t){fn(...a);t=true;setTimeout(()=>t=false,delay)}}}" },
      { "title": "Promise ilə Fetch", "description": "API nəticəsini console-a yazdırın.", "solution": "fetch('https://api').then(r=>r.json()).then(d=>console.log(d));" },
      { "title": "Async Await", "description": "Async funksiyada await istifadə edin.", "solution": "async function getData(){const r=await fetch('url');return await r.json();}" },
      { "title": "Recursive Factorial", "description": "Ədədin faktorialını hesablayın.", "solution": "function fact(n){return n<=1?1:n*fact(n-1)}" },
      { "title": "Arrow Function ilə Map", "description": "Massivdəki ədədləri 2 ilə vurun.", "solution": "const doubled=arr=>arr.map(x=>x*2);" },
      { "title": "Bind nümunəsi", "description": "`this` kontekstini bağlayın.", "solution": "const user={name:'Ali'};function show(){console.log(this.name);}const fn=show.bind(user);fn();" },
      { "title": "Call nümunəsi", "description": "`call` ilə funksiyanı başqa obyektlə çağırın.", "solution": "function hi(){console.log(this.msg)};hi.call({msg:'Salam'});" },
      { "title": "Apply nümunəsi", "description": "`apply` ilə parametr massivini ötürün.", "solution": "function sum(a,b){return a+b};console.log(sum.apply(null,[2,3]));" },
      { "title": "Chaining nümunəsi", "description": "Metodları birləşdirin.", "solution": "class Calc{constructor(n){this.n=n}add(x){this.n+=x;return this}mul(x){this.n*=x;return this}res(){return this.n}}console.log(new Calc(2).add(3).mul(2).res());" },
      { "title": "IIFE ilə counter", "description": "IIFE ilə təcrid olunmuş sayğac yaradın.", "solution": "const counter=(function(){let c=0;return()=>++c})();" },
      { "title": "Default param", "description": "Parametr ötürülməsə default dəyər olsun.", "solution": "function greet(name='qonaq'){return`Salam ${name}`}" },
      { "title": "Spread operator", "description": "İki array birləşdirin.", "solution": "const a=[1,2],b=[3,4];const c=[...a,...b];" },
      { "title": "Rest param", "description": "İstənilən sayda ədəd toplayan funksiya.", "solution": "function sum(...nums){return nums.reduce((a,b)=>a+b)}" },
      { "title": "Pure Function", "description": "Massivə toxunmadan yeni array qaytarın.", "solution": "function addNum(arr,n){return [...arr,n]}" },
      { "title": "Impure Function", "description": "Massivi dəyişdirən nümunə.", "solution": "function pushNum(arr,n){arr.push(n);return arr}" },
      { "title": "Lexical Scope test", "description": "Daxili funksiyadan xarici dəyişənə giriş edin.", "solution": "function outer(){let x=5;function inner(){console.log(x);}inner();}" },
      { "title": "Promise Chain", "description": "Promise-ləri zəncirvari çağırın.", "solution": "Promise.resolve(1).then(r=>r+1).then(console.log);" },
      { "question": "Generator funksiyalar nədir?", "answer": "Generator funksiyalar `function*` ilə yaradılır və `yield` açar sözü ilə nəticələri addım-addım qaytarır." },
      { "question": "Iterator nədir və necə işləyir?", "answer": "Iterator obyektlərdə ardıcıl olaraq elementlərə giriş etməyə imkan verən interfeysdir (`next()` metodu ilə işləyir)." },
      { "question": "Callback Hell problemini necə həll edirik?", "answer": "Promise və async/await istifadə edərək callback hell problemini aradan qaldırmaq olar." },
      { "question": "Promise.all və Promise.race fərqi nədir?", "answer": "`Promise.all` bütün promise-lərin nəticəsini qaytarır, `Promise.race` isə birincisi tamamlanan promise-in nəticəsini." },
      { "question": "Event bubbling və capturing nədir?", "answer": "Event bubbling hadisələrin DOM ağacında yuxarı doğru, capturing isə aşağı doğru ötürülməsidir." },
      { "question": "Context nədir və necə dəyişir?", "answer": "Context funksiyanın çağırıldığı obyektə əsasən `this`-in dəyəridir. `bind`, `call`, `apply` ilə dəyişmək mümkündür." },
      { "question": "Immediately Invoked Arrow Function necə yazılır?", "answer": "(() => { console.log('Run'); })();" },
      { "question": "Factory Function nədir?", "answer": "Factory function obyekt yaradan və qaytaran funksiyadır, `new` açar sözü olmadan işləyir." },
      { "question": "Constructor Function nədir?", "answer": "`new` ilə çağırılan və obyektin instansını yaradan funksiyadır." },
      { "question": "Prototype nədir və nəyə lazımdır?", "answer": "Prototype obyektlərə miras (inheritance) xüsusiyyəti verir, hər obyekt `__proto__` ilə əlaqəlidir." },
      { "question": "Arrow function ilə constructor niyə mümkün deyil?", "answer": "Çünki arrow function-ların `prototype`-u yoxdur və `this`-i sabitdir." },
      { "question": "Immediately Invoked Function nə üçün istifadə olunur?", "answer": "Global namespace-in çirklənməsinin qarşısını almaq üçün." },
      { "question": "Module Pattern nədir?", "answer": "Kodun parçalanmasını və dəyişənlərin gizlədilməsini təmin edən dizayn pattern-dir." },
      { "question": "Singleton pattern nədir?", "answer": "Bir obyektin yalnız bir instansının yaradılmasını təmin edən pattern-dir." },
      { "question": "Memoization nədir?", "answer": "Eyni arqumentlərlə çağırıldıqda nəticəni yadda saxlayaraq performansı artıran texnikadır." },
      { "question": "Currying nə işə yarayır?", "answer": "Funksiyanı tək parametrli funksiyalara bölərək kodu daha çevik edir." },
      { "question": "Pure function-ların üstünlüyü nədir?", "answer": "Test edilə bilən, təkrarlana bilən və yan təsirsiz kod yazmağa imkan verir." },
      { "question": "Asinxron və sinxron funksiyalar fərqi nədir?", "answer": "Sinxron funksiyalar ardıcıl icra olunur, asinxronlar isə `event loop` vasitəsilə sonraya buraxılır." },
      { "question": "Promise chaining necə işləyir?", "answer": "Bir promise-in nəticəsi digər `then()`-ə ötürülür." },
      { "question": "Async function hər zaman nə qaytarır?", "answer": "Async funksiyalar həmişə Promise qaytarır." },
      { "question": "JSON.stringify və JSON.parse nə üçündür?", "answer": "Obyekti stringə çevirmək və ya stringi obyektə çevirmək üçün istifadə olunur." },
      { "question": "Deep copy və shallow copy fərqi nədir?", "answer": "Shallow copy bir səviyyəlik kopyadır, deep copy isə bütün səviyyələri kopyalayır." },
      { "question": "Spread operator və Object.assign fərqi nədir?", "answer": "Spread ES6 sintaksisidir, Object.assign daha köhnə üsuldur; hər ikisi obyekt birləşdirmək üçündür." },
      { "question": "Destructuring nədir?", "answer": "Array və obyektlərdən məlumat çıxarmaq üçün qısa sintaksisdir." },
      { "question": "Immediately Invoked Generator necə çağırılır?", "answer": "(function* () { yield 1; })().next();" },
      { "question": "Hoisting-in riskləri nədir?", "answer": "Dəyişənlərin `undefined` olması və gözlənilməz davranışlara səbəb ola bilməsidir." },
      { "question": "Callback error-first pattern nədir?", "answer": "Node.js-də ənənəvi callback-lərin ilk arqumenti error olur (`callback(err, data)`)." },
      { "question": "Promise.resolve və Promise.reject nə edir?", "answer": "Promise-ləri əl ilə uğurlu və ya uğursuz vəziyyətə gətirir." },
      { "question": "Promise.finally nə edir?", "answer": "Uğur və ya səhv halından asılı olmayaraq hər zaman işləyir." },
      { "question": "Event delegation nədir?", "answer": "Hadisəni valideynə qoşaraq bütün övlad elementləri üçün idarə etmək üsuludur." },
      { "question": "Async Iterator nədir?", "answer": "Asinxron məlumat ardıcıllığını `for await...of` ilə iterasiya etməyə imkan verir." },
      { "question": "Temporal Dead Zone nədir?", "answer": "`let` və `const` dəyişənləri təyin olunmadan istifadə edilən mərhələdir." },
      { "question": "Function parameter destructuring necə edilir?", "answer": "Parametr olaraq obyekt və ya array parçalanaraq qəbul edilir, məsələn `function fn({a,b}){}`" },
      { "question": "Dynamic import nədir?", "answer": "Modulu asinxron şəkildə yükləməyə imkan verir (`import('module.js')`)." },
      { "question": "Module export və default export fərqi nədir?", "answer": "Bir modulda bir default export, amma çox sayda named export ola bilər." },
      { "question": "Revealing module pattern nədir?", "answer": "Funksiyalar və dəyişənləri yalnız qaytarılan obyekt vasitəsilə əlçatan etmək üsuludur." },
      { "question": "Event loop-un stack və queue fərqi nədir?", "answer": "Stack sinxron kodu, queue isə callback və promise-ləri saxlayır." },
      { "question": "Microtask və macrotask fərqi nədir?", "answer": "Microtask (promise) queue prioritetlidir, macrotask (timeout) isə sonra işlənir." },
      { "question": "Scope chain nədir?", "answer": "Daxili funksiyanın xarici scope-lara ardıcıl baxış mexanizmidir." },
      { "question": "Block scope ilə function scope fərqi nədir?", "answer": "`let` və `const` block-a, `var` isə funksiyaya bağlıdır." },
      { "question": "Arrow function 'arguments' obyektini niyə dəstəkləmir?", "answer": "Çünki arrow function-ın öz `arguments` konteksti yoxdur." },
      { "question": "Bind metodunun istifadəsi nə vaxt lazımdır?", "answer": "`this` konteksti itiriləndə (məsələn event listener-də) istifadə olunur." },
      { "question": "Function memoization harada istifadə olunur?", "answer": "Məsələn, API nəticələrinin və ya hesablamaların cache edilməsi üçün." },
      { "question": "Function decorator nədir?", "answer": "Mövcud funksiyanın davranışını dəyişmədən üzərinə əlavə xüsusiyyətlər əlavə edən funksiya." },
      { "question": "Partial application nədir?", "answer": "Funksiya arqumentlərinin bir hissəsini əvvəlcədən doldurmaq üsuludur." },
      { "question": "Callback-lər Promise-lərlə necə əvəz olunur?", "answer": "Callback funksiyalar əvəzinə Promise return edən funksiyalar yazılır." },
      { "question": "Lazy evaluation nədir?", "answer": "Dəyərin yalnız lazım olduqda hesablanması üsuludur." },
      { "question": "Immediately invoked async function necə yazılır?", "answer": "(async()=>{await someTask();})();" }
    ]
  }
]
